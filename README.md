

<<<<<<< HEAD
Copyright (R) 2025,   
=======
Copyright (R) 2025,
>>>>>>> vitali/master
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

Redistributions of source code must retain the above copyright notice, this list of
conditions and the following disclaimer. Redistributions in binary form must reproduce
the above copyright notice, this list of conditions and the following disclaimer in
the documentation and/or other materials provided with the distribution.

<<<<<<< HEAD
Neither the name of ivakhnenkovitali.com   nor the names of its contributors may be used to endorse
=======
Neither the name of ivakhnenkovitali.com nor the names of its contributors may be used to endorse
>>>>>>> vitali/master
or promote products derived from this software without specific prior written
permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF TH

![](../../1.png)




____________________________________________________________________
___________________________________________________________
Copyright (R) 2025,   
Alle Rechte vorbehalten.

Die Redistribution und Nutzung in Quell- und Binärformen, mit oder ohne
Änderungen, sind gestattet, sofern die folgenden Bedingungen erfüllt sind:

Die Weiterverbreitung des Quellcodes muss den oben genannten Copyright-Hinweis, diese Liste der
Bedingungen und den folgenden Haftungsausschluss beibehalten. Die Weiterverbreitung in Binärform muss
den oben genannten Copyright-Hinweis, diese Liste der Bedingungen und den folgenden Haftungsausschluss
in der Dokumentation und/oder anderen Materialien, die mit der Verteilung bereitgestellt werden, wiedergeben.

Weder der Name ivakhnenkovitali.com noch die Namen seiner Mitwirkenden dürfen verwendet werden, um
Produkte, die aus dieser Software abgeleitet sind, ohne ausdrückliche vorherige schriftliche
Genehmigung zu unterstützen oder zu bewerben.

DIESE SOFTWARE WIRD VON DEN COPYRIGHT-INHABERN UND MITWIRKENDEN "WIE BESEHEN" BEREITGESTELLT, UND
ALLE AUSDRÜCKLICHEN ODER IMPLIZIERTEN GARANTIEN, EINSCHLIESSLICH, ABER NICHT BESCHRÄNKT AUF, DIE IMPLIZIERTEN
GARANTIEN DER MARKTFÄHIGKEIT UND EIGNUNG FÜR EINEN BESTIMMTEN ZWECK, WERDEN ABGELEHNT. IN KEINEM FALL
HAFTEN DIE COPYRIGHT-INHABER ODER MITWIRKENDEN FÜR DIREKTE, INDIREKTE, NEBENSÄCHLICHE, BESONDERE,
MUSTERHAFTIGE ODER FOLGESCHÄDEN (EINSCHLIESSLICH, ABER NICHT BESCHRÄNKT AUF, DEN ERWERB VON
ERSATZGÜTERN ODER DIENSTLEISTUNGEN; VERLUST VON GEBRAUCH, DATEN ODER GEWINNEN; ODER
UNTERBRECHUNG DES GESCHÄFTSBETRIEBS), UNABHÄNGIG VON DER URSACHE UND JEDER HAFTUNGSTHEORIE, OB IN
VERTRAG, STRIKTER HAFTUNG ODER DELIKT (EINSCHLIESSLICH FAHRLÄSSIGKEIT ODER ANDERWEITIG), DIE AUF IRGENDEINE
WEISE AUS DER NUTZUNG DIESER SOFTWARE ENTSTEHT, SELBST WENN AUF DIE MÖGLICHKEIT HINGEWIESEN WURDE.

![](../../1.png)




___________________________________________________________

[![Typing SVG](https://readme-typing-svg.herokuapp.com?color=%2336BCF7&lines=Кухня+все+в+одном+месте)](https://git.io/typing-svg)   

______________________________________________________________________
[![Typing SVG](https://readme-typing-svg.herokuapp.com?color=%2336BCF7&lines=Кухня+ўсё+ў+адным+месцы)](https://git.io/typing-svg)   
__________________________________________________________________
_________________________________________________________________
[![Typing SVG](https://readme-typing-svg.herokuapp.com?color=%2336BCF7&lines=Küche+alles+an+einem+Ort)](https://git.io/typing-svg)  
_________________________________________________________________
_________________________________________________________________
[![Typing SVG](https://readme-typing-svg.herokuapp.com?color=%2336BCF7&lines=Kitchen+all+in+one+place)](https://git.io/typing-svg)  
___________________________________________________________
_________________________________________________________________

[![Typing SVG](https://readme-typing-svg.herokuapp.com?color=%2336BCF7&lines=Кушайте+с+удовольствием+без+хлопот+.)](https://git.io/typing-svg)   
________________________________________
___________________________________________
 Кухня-кафе  запуск ЮЗЕРА 

https://www.youtube.com/watch?v=0ABftQLyHfs&t=109s
 
________________________________
запуска и работа
https://www.youtube.com/watch?v=mhTtMqqpajg
___________________________________________
________________________________________


![02](https://github.com/ivakhnenkovitali/final_project_2211/assets/141067997/d506851f-b948-4573-bc0e-57d004bce5ce)
________________________________________________
![03](https://github.com/ivakhnenkovitali/final_project_2211/assets/141067997/650685a8-6a07-4ae4-ab1f-1f861acbf88f)
__________________________________________________
 [![Typing SVG](https://readme-typing-svg.herokuapp.com?color=%2336BCF7&lines=Создадим+проект+Интернет+еда)](https://git.io/typing-svg)на основе архитипа maven -archetype -webapp архетипа и попробуем+его реализовать на последней LTS версии Java. 
Это версия JDK Development Kit 17.0.9. (можно скачать с оффсайта Oracle версию Open JDK).
Архитипа  Maven – это  структура папок и файлов проекта, которые используются при создании проекта.
После того, как maven закончит генерацию проекта чистим pom.xml файл от лишнего,  устанавливаем 17 уровень компайлера и подключаем jetty-maven-plugin (11.0.18). 
В

   ____________________                    
Гэта версія JDK Development Kit 17.0.9. (можна спампаваць з афіцыйнага сайта Oracle версію Open JDK). Архетып Maven – гэта структура тэчак і файлаў праекта, якія выкарыстоўваюцца пры стварэнні праекта. Пасля таго, як Maven скончыць генерацыю праекта, 
файл pom.xml ад лішняга, усталёўваем 17-ы ўзровень кампайлера і падключаем jetty-maven-plugin (11.0.18).

   _________________________
Dies ist die Version des JDK Development Kits 17.0.9. (Die Open JDK-Version kann von der offiziellen Oracle-Website heruntergeladen werden). Das Maven-Archetyp ist die Ordner- und Dateistruktur eines Projekts, die beim Erstellen eines Projekts verwendet wird.
Nachdem Maven die Projekterstellung abgeschlossen hat, bereinigen wir die pom.xml-Datei von unnötigem Inhalt, setzen das Compiler-Level auf 17 und fügen das jetty-maven-plugin (11.0.18) hinzu.
  ___________________________
This is version 17.0.9 of the JDK Development Kit. (You can download the Open JDK version from the official Oracle website). A Maven archetype is the folder and file structure of a project used when creating a project. After Maven finishes generating the project,
we clean the pom.xml file from unnecessary parts, set the compiler level to 17, and add the jetty-maven-plugin (11.0.18).


________________________
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>by.itclass</groupId>
    <artifactId>final_project_2211</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>war</packaging> //файл будет упаковываться в war архив

    <name>final_project_2211 Maven Webapp</name>

    <properties>
        <project.build.sourceEncoding>UTF8</project.build.sourceEncoding>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
    </properties>

// в dependencies – прописываем пакеты, которые будут подключены
    <dependencies>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.30</version>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>jakarta.servlet</groupId>
            <artifactId>jakarta.servlet-api</artifactId>
            <version>6.0.0</version>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>com.mysql</groupId>
            <artifactId>mysql-connector-j</artifactId>
            <version>8.0.33</version>
        </dependency>
        <dependency>
            <groupId>org.glassfish.web</groupId>
            <artifactId>jakarta.servlet.jsp.jstl</artifactId>
            <version>2.0.0</version>
        </dependency>

    </dependencies>

    <build>
        <finalName>final_project_2211</finalName>
        <plugins>
            <plugin>
                <groupId>org.eclipse.jetty</groupId>
                <artifactId>jetty-maven-plugin</artifactId>
                <version>11.0.18</version>
            </plugin>
        </plugins>
    </build>
</project>
Убеждаемся, что у нас установлен 17 уровень для Java Compiler в свойствах Intellij Idea (Build, Execution, Deployment -> Compiler -> Java Compiler).
Убеждаемся, что у нас включен Annotation Processing (Build, Execution, Deployment -> Compiler -> Annotation Processors).
Убеждаемся, что у нас установлен 17 уровень Java для maven runner (Build, Execution, Deployment -> Build Tools -> Maven -> Runner).
Убеждаемся, что у нас выбрана 17 версия Java SDK и уровень языка в свойствах проекта (File -> Project Structure -> Project Settings -> Project).
Убеждаемся, что у нас установлен 17  уровень языка в свойствах модуля (File -> Project Structure -> Project Settings -> Modules).Dependences – SDK 17
Создаем все необходимые директории (java и resources)
Не забываем:

<web-app version="4"> // чтобы заработала jetty-такая особенность

Определились, что будем работать по MVC модели.

Как я раньше говорил - написание проекта нужно начинать с описания бизнес-объектов, поэтому создадим нашу первую бизнес-сущность... это будет пользователь User... Для этого в пакете model.entities создадим класс User. 

@AllArgsConstructor
@RequiredArgsConstructor
@Data
public class User {
    private int id;
    private final String login;
    private final String name;
    private final String email;
}

И хоть у нас и будет использоваться пароль, но он обычно не включается как поле класса, а просто храниться в базе данных...

Теперь приступим к реализации механизма авторизации на основе сервлетов и jsp.
Задача сервлета получить параметры и передать их.

Чтобы не путаться в именах инпутов на форме и параметров в сервлетах (ведь они должны быть одинаковые) – будем хранить значения в классах констант... это позволяет также избегать magic numbers и literal constants.

Создадим в  by.itclass.constants  классы для хранения значений для Фронта и Бэка:

public class JspConstants {
    public static final String LOGIN_PARAM = "login";
    public static final String NAME_PARAM = "name";
    public static final String PASS_PARAM = "password";
    public static final String EMAIL_PARAM = "email";

    public static final String MESSAGE_ATTR = "message";
}

public class ApplicationConstants {

}

Сервлетов у нас будет много... и для того, чтобы избежать дублирования кода, создадим в пакете by.itclass.controllers абстрактный сервлет, от которого будем наследовать необходимые методы и поля.
Для возможности наследования от класса HttpServlet необходимо в pom.xml добавить зависимость (уже добавлен)

<dependency>
   <groupId>jakarta.servlet</groupId>
   <artifactId>jakarta.servlet-api</artifactId>
   <version>6.0.0</version>
   <scope>provided</scope>
</dependency>

@WebServlet(name = "abstractController")

@WebServlet (name=’’ abstractController”) // у абстрактного сервлета нет urlpattern
public abstract class AbstractController extends HttpServlet {
// переопределяем метод doGet, который будет вызывать doPost, метод doPost я
 @Override
    protected void doGet (HttpServletRequest req, HttpServletResponse resp) 
 throws ServletException, IOException {
        doPost(req, resp);
    }

    //просто перейти на некий адрес
// создасться объект, который позволит передать информацию через req и resp , посредством вызова метода forward – который и перенаправит на другой адрес
  public void forwardUrl (HttpServletRequest req, HttpServletResponse resp,
                           String url) throws ServletException, IOException {
        req.getRequestDispatcher (url) .forward(req, resp);
    }


    //перегруженный метод... перейти с сообщением,

// setAttribute – закинет наш message в атрибуты и перенаправит запрос

    public void forwardUrl(HttpServletRequest req, HttpServletResponse resp,
                           String url, String message) throws ServletException, IOException {
        req.setAttribute(MESSAGE_ATTR, message);
        forwardUrl(req, resp, url);
    }

Для хранения бизнес-объектов нашего приложения будем использовать базу данных... Как мы помним, для того чтобы подключиться к нашей базе данных необходимо произвести некоторые телодвижения, а именно:
Добавить в pom.xml зависимость, чтобы подключить пакет для работы с MySQL(подключен)

<dependency>
    <groupId>com.mysql</groupId>
    <artifactId>mysql-connector-j</artifactId>
    <version>8.0.33</version>
</dependency> 

 Создать класс ConnectionManager, у которого будет метод, возвращающий объект класса Connection. Для этого создаем в by.itclass.model.db и сам класс ConnectionManager. 
Можно пойти простым путем и написать приблизительно такое...

@UtilityClass
public class ConnectionManager {
// можно было вынести в properties файл КОД НИЖЕ
    psfs DRIVER_NAME = "com.mysql.cj.jdbc.Driver";
    psfs URL = "jdbc:mysql://localhost:3306/pizza_db";
    psfs USER = "root";
    psfs PASSWORD = "";

    private static Connection cn;
/

    public static void init() {// обработать в try
        Class.forName(DRIVER_NAME);
    }

    public static Connection getConnection() throws SQLException {
        return Objects.isNull(cn) || cn.isClosed()
                ? DriverManager.getConnection(URL, USER, PASSWORD)
                : cn;
// 
    }
}

Но я предложу немного усложнить код, и использовать другой подход. Для этого воспользуемся способом, при котором будем хранить параметры для подключения к базе данных в файле db.properties.
В каталоге resources создадим файл  db.properties (File->New -> Project ->Pesource Bundle !!!!!! или прописать путь без db – смотри правильный адрес) со следующим содержимым:

driver=com.mysql.cj.jdbc.Driver
url=jdbc:mysql://localhost:3306/po_pizza_17_version
user=root
password=
Из этого файла мы будем получать объект старой доброй коллекции Properties. Чем удобна эта коллекция – у нее есть метод, который позволяет данными полученными из файла заполнить коллекцию. 
Для того чтобы читать db.properties в пакете by.itclass.model.db создадим класс   PropertiesManager и у него создадим метод getProperties(…),  в параметры получит константу, которая будет ссылаться на файл db.properties.
// т.к. файл лежит не в директории Java, то считывания будет через FileReader будет организован по другому, через Thread.currentThread() – возвращает текущий поток.

@UtilityClass
public class PropertiesManager {
    public static Properties getProperties(String fileName) {
        var props = new Properties();
        try (var fr = new FileReader(Thread.currentThread()
                .getContextClassLoader().getResource(fileName).getPath())) {
            props.load(fr); // прочитает файл из ресурса и сделает(вернет) из него объект return props
        } catch (IOException e) {
            e.printStackTrace();
        }
        return props;
    }
} Для чего такой сложный код в методе – при компиляции наш файл db.properties попадает в target в каталог с файлами, для того, чтобы PropertiesManager  мог найти этот файл мы должны вызвать в методе .getContextClassLoader()

@UtilityClass
public class ConnectionManager {
    private static final String DRIVER = "driver";
    private static final String URL = "url";
    private static final String DB_FILE_PROPS = "db.properties";
    
    private static Connection cn; // хранит ссылку на объект
    private static Properties props; // коллекция которая будет создана

    public static void init() {
       loadProps(); // создаст properties
       loadDriver(); // загрузит драйвер
}
    public static void loadDriver() {
        try {
            Class.forName(props.getProperty(DRIVER));
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
	Создадим метод getConnection, который проверит есть ли объект isNull  и не закрыт ли он isClosed. Если все хорошо получит коннекшион с БД.

    public static Connection getConnection() throws SQLException {
       return Objects.isNull(cn) || cn.isClosed()
           ? DriverManager.getConnection(props.getProperty(URL), props)
           : cn;
    }
}
Позже это будет рефакторится, поскольку такой метод хорош при одном контроллере... а вот если их много, а по определению все наши контроллеры наследуются от абстрактного, то нету гибкости – поскольку мы тупо всегда будем получать коннекшен к MySql...

Опять же... пишем приложение на основе паттерна MVC – будем создавать все слои... сервис, дао... т.к. у нас должна быть прослойка между сервлетами и model (т.е. service - получит параметры от сервлета и на основе этих параметров выберет соответствующий метод в dao и dao –поэтому dao должен соединиться с service)  (Хотя в нашем случае слой сервисов и не обязателен)
Первым создадим класс UserDao в пакете model.dao

public class UserDao {
    private static UserDao dao;

    private UserDao() {
        ConnectionManager.init(); // чтобы сработал dao вызываем метод init() из др класса
    }

// проверит есть ли dao, если нет создаст
    public static UserDao getInstance() { 
        return Objects.isNull (dao) ? new UserDao() : dao;
    }

// проверит есть ли User с таким логином и паролем
    public User getUser (String login, String password) {
        return null;
    }
// проверит добавился ли User в БД
    public boolean addUser (User user, String password) {
        return true;
    }
}

Что же происходит в этом классе... при создании объекта этого класса вызывается метод класса ConnectionManager, который создает объект Properties и загружает в память Driver), после чего мы можем получать соединение с базой данных.... Причем инициализация происходит один раз, поскольку мы реализовали такую логику (ведь на самом деле этот метод вызывается в конструкторе, а мы сделали синглтон)....

Далее напишем класс UserService в пакете model.services

public class UserService {
    private static UserService service;
    private UserDao dao;

    public UserService() {
        dao = UserDao.getInstance(); //конструктор вызовет др метод
    }
// проверит есть ли service, если нет создаст

    public static UserService getInstance() {
        return Objects.isNull(service) ? new UserService() : service;
    }
// вернет user, пойдет в классUserDao  и там реализует метод

    public User getUser(String login, String password) {
        return dao.getUser(login, password);
    }
// добавит user , пойдет в классUserDao  и там реализует метод
    public boolean addUser(User user, String password) {
        return dao.addUser(user, password);
    }
}

Ну и напишем первый контролер для работы с пользователями в пакете controllers.user. В user будут храниться сервлеты, которые будут отвечать за login, logout, registration.
Перед написанием добавим в наш класс констант ApplicationConstants приложения URL этого контроллера

public class ApplicationConstants {
    // для сервлетов
    public static final String LOGIN_CONTROLLER = "/login";
    public static final String USER_NOT_FOUND = "User is not found";
}

а в класс констант нашего фронта class JspConstants

public static final String MESSAGE_ATTR = "message";
public static final String USER_ATTR = "user";

public static final String LOGIN_JSP = "/jsp/login.jsp"; // путь, где будут храниться наши странички
public static final String HOME_JSP = "/jsp/home.jsp";



Реализация контроллера

В пакете controllers создаем пакет User

@WebServlet(urlPatterns = LOGIN_CONTROLLER)
public class LoginController extends AbstractController {
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        var login = req.getParameter(LOGIN_PARAM);
        var password = req.getParameter(PASS_PARAM);

        var user = userService.getUser(login, password);
        if (!Objects.isNull(user)) {
            var session = req.getSession();
            session.setAttribute(USER_ATTR, user);
            forwardUrl(req, resp, HOME_JSP);
        } else {
            forwardUrl(req, resp, LOGIN_JSP, USER_NOT_FOUND);
        }
    }
} 
// Из первой страницы мы получим объекты логин и пароль (т.е. то что ввел пользователь) через getParameter. Обратимся к userService.getUser  и передадим наши объекты(логин и пароль). Service обратиться к dao ….. и вернет user.
Т.к. у нас один user работаем с if и проверяем есть ли у нас user в БД.
Если да – то сохраним его в session  и перенаправим на страницу Home.
Если нет  такого user то перенаправим пользователя на первую страничку (регистрация) и дадим сообщение об ошибке.

Инициализацию UserService вынесем в абстрактный класс abstract class AbstractController (добавим поле userService и метод init

protected UserService userService;

@Override
public void init() throws ServletException {
   userService = UserService.getInstance();
}

Напишем страницу – home.jsp, в каталоге /jsp на которой будем отображать информацию о пользователе, если он найден


<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
    <head>
        <title>Home Page</title>
    </head>
    <body>
        <h2>User Info</h2>
        <p>login: ${user.login}</p>
        <p>name : ${user.name}</p>
        <p>email: ${user.email}</p>
    </body>
</html>

Ну и конечно же напишем страницу, на которой пользователь может произвести авторизацию – login.jsp. 
<%@ page import="constants.ApplicationConstants" %>
<%@ page import="constants.JspConstants" %>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<html>
<head>
    <title>Login page</title>
    <link rel="stylesheet" href="/css/styles.css">
</head>
<body>
        <h2>Login</h2>
     <form method="post" action="<%=ApplicationConstants.LOGIN_CONTROLLER%>">
     <input name="<%= JspConstants.LOGIN_PARAM%>" placeholder="login">
<input type="password"name="<%=JspConstants.PASS_PARAM%>"placeholder="Password">
      <input type="submit" value="Login">
        </form>
        <c:if test="${not empty message}">
            <h2 class="error">${message}</h2>
        </c:if>
    </div>
</body>
</html>

Для того, чтобы было красиво, добавим немного стилей... тем более, что мы их уже подключили на странице – файл styles.css в директории /css.
.form-box {
   text-align: center;	 		     
   background-color: lightgray;      
   border: 10px solid green;         
   margin: 20px;		               
   left: 35%;
  position: absolute;
  width: 300px;
  padding: 50px;
  top: 30%;
}

input{
   width: 200px;		               
  	 margin: 5px;
	padding: 5px;
}

input[type=submit]{
   width: 120px;		               
   border: none;                     		  
   padding: 16px 32px;		          
   margin: 4px 2px;		          
  background-color: green;
  color: white;	
  text-decoration: none;
  cursor: pointer;
}

.error{
    color: red;
}

Ну и наконец-то перейдем к реализации методов dao, а именно метода поиска пользователя в базе данных. 
Создадим еще один файл с константами... в нем мы будем хранить все для работы с базой данных.. DbConstants
psfs ID_COL = "id";
psfs LOGIN_COL = "login";
psfs NAME_COL = "name";
psfs PASS_COL = "password";
psfs EMAIL_COL = "email";
psfs PRICE_COL = "price";

// опишем наш запрос
psfs SELECT_USER = "SELECT id, name, email FROM user WHERE login = ? AND password = ?";

Ну и сама реализация метода в классе UserDao:

public User getUser(String login, String password) {
   try (var cn = ConnectionManager.getConnection(); // соединение с коннекшинам
        var ps = cn.prepareStatement(SELECT_USER)) {// вызов запроса (существ 2 метода)
// значение вопросов в полей, сколько вопросов в запросе столько и ps
      ps.setString(1, login);// setString т.к. login – имеет тип String
      ps.setString(2, password); setString т.к. password – имеет тип String СМОТРИ ТИП ПОЛЕЙ
      var resultSet = ps.executeQuery(); //создание виртуальной таблицы
      if(resultSet.next()) { //т.к. речь идет об одном пользователе, поэтому через if
         var id = resultSet.getInt(ID_COL);
         var name = resultSet.getString(NAME_COL);
         var email = resultSet.getString(EMAIL_COL);
         return new User(id, login, name, email); //вернет user
      }
   } catch (SQLException e) {
      e.printStackTrace();
   }
   return null; // если нет вернет null
}


Для проверки создадим базу данных po__17_version 

CREATE DATABASE po_17_version;

в базе данных создадим таблицу user, с соответствующими полями



Авторизация готова
 P.S. и даже если закрыть все окна браузера, юзер хранится в сессии.... 



Работа с пользователями будет состоять из трех процессов, один из которых мы уже реализовали.. приступим к реализации второго (logout) для этого создадим новый сервлет. Для выхода – нужно удалить все сведения, которые хранятся на сервере... т.е. тупо убить сессию. 
Инвалидируем сессию и делаем redirect не путать с forward и переадресует на страницу логина. Это убъет сведения обо всех действиях... 
В абстрактном контроллере создадим метод redirect():

protected void redirect(HttpServletResponse resp, String url) 
                        throws IOException {
   resp.sendRedirect(getServletContext().getContextPath() + url);
// sendRedirect – переадресует 
// getServletContext – некая папка которая храниться и создается на сервере, в которую будет деплоиться наш контекст
// getContextPath – путь к контексту
}

добавляем в файл ApplicationConstants  констант новый путь к сервлету..

psfs LOGOUT_CONTROLLER = "/logout";

и в нашем пакете controllers.user создаем новый класс сервлет LogoutController и переопределяем метод doPost этот метод...

@WebServlet(urlPatterns = LOGOUT_CONTROLLER)
public class LogoutController extends AbstractController {
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        var session = req.getSession();
        session.invalidate();
        resp.sendRedirect(LOGIN_JSP);
    }
}
Вспоминаем отличие форварда от редиректа – форвард применяется для передачи пары запрос-ответ внутри приложения... и клиент даже не подозревает об этих передачах и при получении ответа думает, что он его получил от ресурса, у которого он и запрашивал информацию.  Метод sendRedirect содержит в себе информацию о ресурсе, на который будет перенаправление, но он просит клиента отправить на эту страницу новую пару запрос-ответ, а о старой паре забывает... т.е. браузер формирует новый запрос (юзер также может не знать об этом, но формируется новый запрос)!!!
Поскольку редирект работает и со внешними ресурсами, нужно указывать полный путь... именно поэтому нужны были танцы в сервлете (контекст).

И добавим на home.jsp ссылку на ЛОГАУТ КОНТРОЛЛЕР

<%@ page import="by.itclass.constants.ApplicationConstants"%>
<%@ page contentType="text/html;charset=UTF-8" language="java"%>
<html>
  <head>
    <title>Home Page</title>
  </head>
  <body>
    <p>
      <a href="<%=ApplicationConstants.LOGOUT_CONTROLLER%>">Logout</a>
    </p>
    <h2>User Info</h2>
    <p>login: ${user.login}</p>
    <p>name : ${user.name}</p>
    <p>email: ${user.email}</p>
  </body>
</html>

Выход готов
 P.S. проверить легко – если не нажимая на logout просто закрыть вкладку, а потом попытаться перейти по ссылке /jsp/home.jsp  - то сведения о пользователе будут отображаться... если же нажать logout -  то не будут 
Ну и третий этап работы с юзерами – это регистрация. 
Регистрацию пользователя пользователя также как и логин будем производить с помощью формы. Для этого создадим в каталоге /jsp страницу для регистрации registration.jsp  практически скопировав логин страничку, просто экшен у формы будет другой и полей на форме будет побольше.
<html>
<head>
  <title>Registration page</title>
  <link rel="stylesheet" href="/css/styles.css">
</head>
<body>
  <div class="form-box">
    <h2>Registration</h2>
    <form method="post" action="<%=ApplicationConstants.
                                            REGISTRATION_CONTROLLER%>">
      <input name="<%=JspConstants.NAME_PARAM%>" placeholder="Name">
      <input name="<%=JspConstants.EMAIL_PARAM%>" placeholder="eMail">
      <input name="<%=JspConstants.LOGIN_PARAM%>" placeholder="Login">
      <input type="password" name="<%=JspConstants.PASS_PARAM%>" 
                                                placeholder="Password">
      <input type="submit" value="Register">
    </form>
    <c:if test="${not empty message}">
       <h2 class="error">${message}</p>
    </c:if>
  </div>
</body>
</html>
И добавим новые пути в константы в класс ApplicationConstants
psfs REGISTRATION_CONTROLLER = "/registration";
psfs USER_NOT_REGISTERED = "Registration is not success";

и в класс константы JspConstants
psfs REGISTRATION_JSP = "/jsp/registration.jsp";

Итак... страница отправляет запрос на контроллер, который мы и должны создать...

@WebServlet(urlPatterns = REGISTRATION_CONTROLLER)
public class RegistrationController extends AbstractController {
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        var login = req.getParameter(LOGIN_PARAM);
        var name = req.getParameter(NAME_PARAM);
        var password = req.getParameter(PASS_PARAM);
        var email = req.getParameter(EMAIL_PARAM);
        var user = new User(login, name, email);
        if (userService.addUser(user, password)) {
            redirect(resp, LOGIN_JSP);
        } else {
            forwardUrl(req, resp, REGISTRATION_JSP, USER_NOT_REGISTERED);
        }

    }
}
Добавим новый запрос в константы DbConstants
psfs INSERT_USER = "INSERT INTO user (name, email, login, password)  values (?, ?, ?, ?)";
и в классе UserDao переопределим метод, который будет добавлять пользователя в базу данных и возвращать нам булево значение... причем в этом же классе напишем метод, который будет проверять занят ли login. Для этого метода также добавим константу строки запроса DbConstants.

psfs SELECT_USERID_BY_LOGIN = "SELECT id FROM user WHERE login = ?";

и наконец... реализация методов в UserDao
 
public boolean addUser(User user, String password) {
   try (var cn = ConnectionManager.getConnection();
      var ps = cn.prepareStatement(INSERT_USER)) {
      if (isAccessible(user.getLogin(), cn)) {
         ps.setString(1, user.getName());
         ps.setString(2, user.getEmail());
         ps.setString(3, user.getLogin());
         ps.setString(4, password);
         return ps.executeUpdate() > 0;
// если был добавлен user, то executeUpdate вернет Boolean  значение 1 – это значит что добавлен
      }
   } catch (SQLException e) {
      e.printStackTrace();
   }
   return false; // если не 1 (это значит  не добавлен)
}

// проверит не занят ли логин в БД (он сходит в БД и проверит только логин , остальное нас не интересует по задаче, можно добавить лобое поле)
// ПЕРЕДАЕМ Connection cn – чтобы не вызывать повторно, метод все равно работает с копией String login, Connection cn – поэтому Connection не закроется
private boolean isAccessible(String login, Connection cn) 
                             throws SQLException {
   try (var ps = cn.prepareStatement(SELECT_USERID_BY_LOGIN)) {
      ps.setString(1, login);
      return !ps.executeQuery().next(); // если такого логина нет – вернет false 
   } catch (SQLException e) {
      e.printStackTrace();
   }
   return false; // если такого логина нет – вернет false(ЧТОБЫ НЕ БЫЛО КОНФЛИКТА ДУБЛИРУЕМ)
}

Все конечно работает, но гораздо приятней не писать пути вручную, а нажимать кнопки, поэтому сделаем файл menu.jsp и будем его подключать на все страницы 
В JspConstant  пропиши констант menu.jsp
    public static final String MENU_JSP = "/jsp/menu.jsp";

<%@ page import="by.itclass.constants.ApplicationConstants"%>
<%@ page import="by.itclass.constants.JspConstants"%>
<%@ page contentType="text/html;charset=UTF-8" language="java"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%>
<ul class="nav-ul">
  <c:choose>
    <c:when test="${empty user}">
     <li class="nav-li float-left">
       <a class="active" href="<%=JspConstants.INDEX_JSP%>">Index</a></li>
     <li class="nav-li">
       <a href="<%=JspConstants.LOGIN_JSP%>">Login</a></li>
     <li class="nav-li">
       <a href="<%=JspConstants.REGISTRATION_JSP%>">Registration</a></li>
    </c:when>
    <c:otherwise>
     <li class="nav-li float-left">
       <a class="active" href="<%=JspConstants.HOME_JSP%>">Home</a></li>
     <li class="nav-li">
       <a href="<%=ApplicationConstants.LOGOUT_CONTROLLER%>">Logout</a>
     </li>
    </c:otherwise>
  </c:choose>
</ul>

Дополним стили

.nav-ul{
   list-style-type: none;            
   padding: 0;                       
   background-color: gray;
  margin: 0;
  overflow: hidden;
}

.nav-li{
   float: right;}

.nav-li.float-left{
   float: left;}

.nav-li a{
   display: block;                   
   text-align: center;               
   text-decoration: none;
   color: white;
   padding: 14px 16px;
}

.nav-li a:hover:not(.active){
   background-color: dimgray;}

.active {
   background-color: green;}


В JspConstant  пропиши констант menu.jsp
    public static final String INDEX_JSP = "/index.jsp";

Создадим стартовую страницу index.jsp и подключим на нее файл menu.jsp с помощью директивы jsp:include.

<%@ page import="by.itclass.constants.JspConstants" %>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
  <head>
    <title>Pizza_2211</title>
    <link rel="stylesheet" href="/css/styles.css">
  </head>
  <body>
    <jsp:include page="<%=JspConstants.MENU_JSP%>"/>
    <img class="default-image" src="<%=JspConstants.BACKGROUND_IMAGE%>">
   <h1 style="position:absolute; top:50%; width:100%; text-align:center;">
               The most tasty pizza!!!
    </h1>
  </body>
</html>

Добавим в файл JspConstants путь к картинке 

public static final String BACKGROUND_IMAGE = "/img/pizza-dinner.jpg";


Добавим стили для картинки

.default-image {    
	width: 100%;  
      opacity: 0.5;
}
Для картинок создадим отдельную директорию img и поместим туда бэкграунд картинку...

Также подключим файл menu.jsp и поместим картинку на страницы login.jsp  и  registration.jsp
Стр11 и 12

<jsp:include page="<%=JspConstants.MENU_JSP%>"/>
<img class="default-image" src="<%=JspConstants.BACKGROUND_IMAGE%>">

И чтобы не было зазоров по бокам добавим стиль для элемента body

body {
    margin: 0px;
}
Итак мы реализовали работу с пользователями, которая состоит из 3-х блоков – логин, регистрация и выход. 

Приступим к написанию непосредственно нашей пиццерии... 

Создадим таблицу, в которой будем хранить позиции меню нашей пиццерии

CREATE TABLE foodItem (
   id int NOT NULL AUTO_INCREMENT PRIMARY KEY,
   foodTypeId int NOT NULL,
   name varchar(50) NOT NULL,
   price double NOT NULL
);

INSERT INTO foodItem (foodTypeId, name, price) VALUES
   	(1, 'Margherita', 15.99), (1, 'Napoletana', 17.99),
   	(1, 'Carbonara', 25.99), (1, 'Peperoni', 25.99),
   	(2, 'Beer', 9.50), (2, 'Cola', 2.50),
   	(2, 'Tea', 3.50), (2, 'Coffee', 9.50);


Создадим таблицы, в которых будет храниться заказы и позиции из этого заказа

CREATE TABLE orders (
   id varchar(50) NOT NULL PRIMARY KEY,
   date date NOT NULL,
   userId int NOT NULL,
   address varchar(50) NOT NULL,   
   FOREIGN KEY (userId) REFERENCES user (id)
                    ON DELETE CASCADE ON UPDATE RESTRICT
);

CREATE TABLE orderItem (
   orderId varchar(50) NOT NULL,
   itemId int NOT NULL,
   quantity int NOT NULL,
   FOREIGN KEY (orderId) REFERENCES orders (id)
                    ON DELETE CASCADE ON UPDATE RESTRICT,
   FOREIGN KEY (itemId) REFERENCES foodItem (id)
                    ON DELETE CASCADE ON UPDATE RESTRICT            
);
По традиции начнем с модели, в пакете  model.entities создадим класс FoodItem

@AllArgsConstructor
@Data
@EqualsAndHashCode
public class FoodItem {
    private int id;
    private int type;
    private String name;
    private double price;
}

Дополним наше menu.jsp несколькими кнопками, которые будут показываться только авторизованному пользователю, нажав на которые он сможет посмотреть меню, предлагаемое пиццерией. (Pizza и Drinks)

<li class="nav-li float-left">
    <a href="<%=ApplicationConstants.PIZZAS_MENU%>">Pizza</a></li>
<li class="nav-li float-left">
    <a href="<%=ApplicationConstants.DRINKS_MENU%>">Drink</a></li>

И соответственно добавим в класс ApplicationConstants эти ссылки:

public static final String MENU_CONTROLLER = "/menu";
public static final String PIZZAS_MENU = "/menu?foodType=1";
public static final String DRINKS_MENU = "/menu?foodType=2";

Две последние ссылки сделаны так нарочно... нам нужно пнуть сервлет и передать всего одн параметр... этот параметр передаем не с помощью формы, а напрямую в URL.

Как и с пользователем начнем писать наш код начиная с уровня DAO

public class FoodDao {
    private static FoodDao dao;

    private FoodDao() {	ConnectionManager.init(); }

    public static FoodDao getInstance() {
        return Objects.isNull(dao) ? new FoodDao() : dao;
    }

    public List<FoodItem> getFoodItemsByType(int foodType) {
       var items = new ArrayList<FoodItem>();
       try (var cn = ConnectionManager.getConnection();
            var ps = cn.prepareStatement(SELECT_FOOD_ITEMS_BY_TYPE)){
          ps.setInt(1, foodType);
          var resultSet = ps.executeQuery();
          while (resultSet.next()) {
             var id = resultSet.getInt(ID_COL);
             var name = resultSet.getString(NAME_COL);
             var price = resultSet.getDouble(PRICE_COL);
             items.add(new FoodItem(id, foodType, name, price));
          }
       } catch (SQLException e) { 
          e.printStackTrace();
       }
       return items;
    }
}
Дополним файл DbConstants

psfs PRICE_COL = "price";
psfs SELECT_FOOD_ITEMS_BY_TYPE = "SELECT id, name, price FROM foodItem 
                                  WHERE foodTypeId = ?";
Соответственно service для сервлета:

public class FoodService {
   private static FoodService service;
   private FoodDao dao;

   private FoodService() { dao = FoodDao.getInstance(); }
 
   public static FoodService getInstance() {
      return Objects.isNull(service) ? new FoodService() : service;
   }
    
   public List<FoodItem> getFoodItemsByType(int foodType) {
      return dao.getFoodItemsByType(foodType);
   }
}

И когда вся логика по извлечению написана, приступим к сервлету, который нам будет доставать из базы данных айтемы, в зависимости от их типа. В пакете controllers.food создадим класс MenuController...

Инициализацию сервиса также вынесем в абстракный сервлет

@WebServlet(value = MENU_CONTROLLER)
public class MenuController extends AbstractController {
  @Override
  protected void doPost(HttpServletRequest req, HttpServletResponse
                         resp) throws ServletException, IOException {
    var foodType = Integer.parseInt(req.getParameter(FOOD_TYPE_PARAM));
    var items = foodService.getFoodItemsByType(foodType);
    enrichRequest(req, foodType, items);
    forward(req, resp, HOME_JSP);
  }

  private void enrichRequest(HttpServletRequest req, int foodType, 
                             List<FoodItem> items) {
    switch (foodType) {
      case 1 -> req.setAttribute(PIZZA_ATTR, items);
      case 2 -> req.setAttribute(DRINK_ATTR, items);
    }
  }
}
Дополним класс JspConstants новыми константами

public static final String FOOD_TYPE_PARAM = "foodType";
public static final String PIZZA_ATTR = "pizzas";
public static final String DRINK_ATTR = "drinks";

Я выбрал для получения меню способ запроса, вместо хранения его в сессии... мне показалось это более логичным. 
Поскольку мы хотим давать возможность просматривать меню только авторизованным пользователям то сервлет форвардит наш запрос на home страничку. 
Напишем же код, который покажет полученные данные. Не забываем, что файл home.jsp у нас уже создан... просто поменяем его содержимое

<body>
 <jsp:include page="<%=JspConstants.MENU_JSP%>"/>
 <h2>Hello ${user.name}</h2>
 <h1>Some content can be placed here... i.e. slider...<h2>
 <c:if test="${not empty pizzas}">
   <h2>Today we propose next pizzas:</h2>
   <c:forEach var="pizza" items="${pizzas}">
     <div class="food-item-box">
       <img class="small-image" src="/img/${pizza.name}.jpg" alt="pizza">
       <p>Name: ${pizza.name}</p>
       <p>Price: ${pizza.price} byn.</p>
     </div>
   </c:forEach>
 </c:if>
 <c:if test="${not empty drinks}">
   <h2>Today we propose next drinks:</h2>
   <c:forEach var="drink" items="${drinks}">
     <div class="food-item-box">
       <img class="small-image" src="/img/${drink.name}.jpg" alt="drink">
       <p>Name: ${drink.name}</p>
       <p>Price: ${drink.price} byn.</p>
     </div>
   </c:forEach>
 </c:if>
</body>

Добавим прекрасных стилей, для более-менее красивого показа

.food-item-box {  
   background-color: lightgray;      width: 200px;
   height: 251px;                    border: 3px solid green;
   padding: 15px;                    margin: 25px;
   display: inline-block;            vertical-align: top; }

.small-image {  width: 200px; }


Конечно, показать меню – это достижение... но было бы прикольно и добавить чего-нить в корзину... 
Чтобы нам было чего добавлять – напишем класс OrderItem в пакете model.entities. Данный класс будет хранить соответствие определенному заказу некоторого пункта меню, а также количество заказанных продуктов 

@Data
@EqualsAndHashCode
@RequiredArgsConstructor
public class OrderItem {
    private String orderId;
    private final FoodItem item;
    private final int quantity;
}

Возможность заказать продукт организуем в виде форм, которые поместим на нашу home.jsp страницу в каждый айтем меню. 
Для пиццы 

<form method="post" action="<%=ApplicationConstants.CART_CONTROLLER%>">
  <input type="hidden" name="<%= JspConstants.CARD_ACTION_PARAM%>" 
  	value="addToCard">
  <input type="hidden" name="<%= JspConstants.FOOD_ID_PARAM%>"
     value="${pizza.id}">
  <input type="hidden" name="<%=JspConstants.FOOD_TYPE_PARAM%>" value="1">
  <input type="hidden" name="<%= JspConstants.FOOD_NAME_PARAM%>" 
     value="${pizza.name}">
  <input type="hidden" name="<%= JspConstants.FOOD_PRICE_PARAM%>"
     value="${pizza.price}">
  <input type="number" name="<%=JspConstants.FOOD_QUANTITY_PARAM%>" 
     required>
  <input type="submit" value="Add to Cart">
</form>

Для напитков 

<form method="post" action="<%=ApplicationConstants.CART_CONTROLLER%>">
  <input type="hidden" name="<%= JspConstants.CARD_ACTION_PARAM%>" 
  	value="addToCard">
  <input type="hidden" name="<%= JspConstants.FOOD_ID_PARAM%>"
     value="${drink.id}">
  <input type="hidden" name="<%=JspConstants.FOOD_TYPE_PARAM%>" value="2">
  <input type="hidden" name="<%= JspConstants.FOOD_NAME_PARAM%>" 
     value="${drink.name}">
  <input type="hidden" name="<%= JspConstants.FOOD_PRICE_PARAM%>"
     value="${drink.price}">
  <input type="number" name="<%=JspConstants.FOOD_QUANTITY_PARAM%>" 
     required>
  <input type="submit" value="Add to Cart">
</form>

Стили для форм
input[type=number] {
   width: 45px;                      padding: 5px; }

.food-item-box input[type=submit] {
   width: 100px;                     height: 30px;
   background-color: green;          border: none;
   color: white;                     padding: 5px;
   text-decoration: none;            margin-left: 35px;
   cursor: pointer; }

Данныя форма будет отправлять на сервлет сведения о заказанном продукте и его количестве, таким образом формируя корзину заказа. 

Поместим в класс ApplicationConstants адрес нового контроллера

public static final String CART_CONTROLLER = "/cart";

Дополним класс JspConstants новыми константами

public static final String FOOD_ID_PARAM = "id";
public static final String FOOD_NAME_PARAM = "name";
public static final String FOOD_PRICE_PARAM = "price";
public static final String FOOD_QUANTITY_PARAM = "quantity";
public static final String CARD_ACTION_PARAM = "cardAction";   
public static final String ORDER_ITEMS_ATTR = "orderItems";

Вновь сначала напишем сервис и по привычке инициализируем его в абстрактном контроллере 

public class CartService {
   private static CartService service;

   public static CartService getInstance() {
      return service == null ? new CartService() : service; }

   public List<OrderItem> processCard(HttpSession session, 
                                    String cardAction, OrderItem item){
      Object orderItems = session.getAttribute(ORDER_ITEMS_ATTR);
      List<OrderItem> items = !Objects.isNull(orderItems)
          ? (List<OrderItem>) orderItems
          : new ArrayList<>();
      switch (cardAction) {
         case "addToCard" -> items.add(item);
         case "removeFromCart" -> items.remove(item);
      }
      return items;
   }
}
Поскольку айтемы хранятся в сесии и обращения к внешней БД нету, то не нужно ДАО. 
А вот и сам сервлет, его кстати напишем в пакете controllers/order

@WebServlet(value = CART_CONTROLLER)
public class CartController extends AbstractController {
  @Override
  protected void doPost(HttpServletRequest req, HttpServletResponse resp){
    var id = Integer.parseInt(req.getParameter(FOOD_ID_PARAM));
    var foodType = Integer.parseInt(req.getParameter(FOOD_TYPE_PARAM));
    var foodName = req.getParameter(FOOD_NAME_PARAM);
    var foodPrice= Double.parseDouble(req.getParameter(FOOD_PRICE_PARAM));
    var foodQuant=Integer.parseInt(req.getParameter(FOOD_QUANTITY_PARAM));
    var cardAction = req.getParameter(CARD_ACTION_PARAM);
    var item = new OrderItem(
              new FoodItem(id, foodType, foodName, foodPrice), foodQuant);
    var session = req.getSession();
    var items = cartService.processCard(session, cardAction, item);
    session.setAttribute(ORDER_ITEMS_ATTR, items);
    if ("addToCard".equals(cardAction)) {
       redirectToMenuPage(resp, foodType);
    } else {
       redirect(resp, CART_JSP);
    }
  }
  private void redirectToMenuPage(HttpServletResponse resp, int foodType){
    switch (foodType) {
      case 1 -> redirect(resp, PIZZAS_MENU);
      case 2 -> redirect(resp, DRINKS_MENU);
    }
  }
}

Дополним наше меню  menu.jsp
<li class="nav-li">
       <a href="<%=JspConstants.CART_JSP%>">Cart</a></li>

Файл констант (JspConstants)
public static final String CART_JSP = "/jsp/cart.jsp";

И приступим к написанию странички, на которой мы сможем видеть нашу корзину и иметь возможность удалить из корзины айтемы (для упрощения я не обращал внимания на количество можете сами сделать), тем более мы ее только что объявили в константах.

<body>
  <jsp:include page="<%=JspConstants.MENU_JSP %>"/>
  <h2>Hello ${user.name}</h2>
  <c:choose>
    <c:when test="${not empty orderItems}">
      <h2>Yours order items: </h2>
      <c:forEach var="item" items="${orderItems}">
        <div class="cart-item-container">
          <img class="cart-img" src="/img/${item.item.name}.jpg">
          <h3 class="cart-text">You ordered ${item.quantity} 
               ${item.item.name} by ${item.item.price} byn. Amount is
               ${item.quantity * item.item.price}</h3>
<form method="post" action="<%=ApplicationConstants.CART_CONTROLLER%>">
   <input type="hidden" name="<%= JspConstants.CARD_ACTION_PARAM %>" 
        value="removeFromCart">
   <input type="hidden" name="<%= JspConstants.FOOD_ID_PARAM %>" 
        value="${item.item.id}">
   <input type="hidden" name="<%= JspConstants.FOOD_TYPE_PARAM %>" 
        value="${item.item.type}">
   <input type="hidden" name="<%= JspConstants.FOOD_NAME_PARAM %>" 
        value="${item.item.name}">
   <input type="hidden" name="<%= JspConstants.FOOD_PRICE_PARAM %>" 
        value="${item.item.price}">
   <input type="hidden" name="<%= JspConstants.FOOD_QUANTITY_PARAM %>" 
        value="${item.quantity}">
   <input type="submit" value="Remove from Cart">
</form>
        </div>
      </c:forEach>
      Сюда добавить order – чутка дальше будет
    </c:when>
    <c:otherwise>
      <p>You have no items in the order</p>
    </c:otherwise>
  </c:choose>
</body>
Стили:

.cart-item-container {
   height: 80px; }

.cart-img {   
   height: 60px;                     float: left;
   border: 1px solid black;          margin: 5px 50px 10px 0px; }

.cart-text {
   margin: 0 0 10px; }

.cart-item-container input[type=submit] {
   width: 140px;                     height: 35px;
   background-color: green;          border: none;
   color: white;                     padding: 10px 10px;
   text-decoration: none;            margin: 0px 3px;
   cursor: pointer; }

Все действия по добавлению и удалению позиций корзины пока происходят в сессии, созданной для пользователя...  на странице корзины мы также сделаем возможность сабмитнуть наш заказ, предварительно введя адрес доставки – обратим внимание, что это поле сделано реквайред. 
                          









